# 数据结构之———树

![自然树](https://xymbucket.oss-cn-beijing.aliyuncs.com/blogs/Images/20211222224740.png)

[TOC]

## 1.概念

### 1.1 术语
>父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点
子节点：一个节点含有的子树的根节点称为该节点的子节点
兄弟节点：拥有共同父节点的节点互称为兄弟节点
节点的度：一个结点含有的子结点个数称为该结点的度;
叶子节点：度为零的节点就是叶子节点
森林：n颗*互不相交*的树构成的集合就是森林

### 1.2 结构逻辑
① 除根节点(root)之外其他节点仅有一个父节点
② 除叶子节点之外，其他节点均有一个或多个子节点
③ 父子节点之间通过指针引用
![简单逻辑图](https://xymbucket.oss-cn-beijing.aliyuncs.com/blogs/Images/20211222232414.png)

### 1.3 树的种类

![分类](https://xymbucket.oss-cn-beijing.aliyuncs.com/blogs/Images/20211223145819.png)

#### A类（概念清晰）

- 无序树：树中任意节点的 子结点之间没有顺序关系，也称为自由树
- 有序树：树中任意节点的 子结点之间有顺序关系
- 二叉树：每个节点最多包含两个子节点的树
- 满二叉树：叶节点除外的所有节点均含有两个子树的树被称为满二叉树
- 完全二叉树：一个树去掉最后一层，剩下部分为满二叉树，则该树称为完全二叉树
- 平衡二叉树（AVL树）：一颗树中所有节点的左右两棵子树高度差绝对值不超过1
    平衡因子（bf）：左子树深度与右子树的深度差[-1 <= bg <= 1]
平衡树转换图：
1.右旋（左旋类似操作）
![LL类型](https://xymbucket.oss-cn-beijing.aliyuncs.com/blogs/Images/20211227222831.png)
![LL复杂类型](https://xymbucket.oss-cn-beijing.aliyuncs.com/blogs/Images/20211227223547.png)
- 二叉搜索树：左节点值 < 父节点值 < 右节点值

#### B类（带图解析）

- **霍夫曼树**：又称最优二叉树，带权路径长度最短的二叉树（带权路径-所有叶子节点的权值乘上叶子节点的深度之和）

        给定所有叶子节点权值为[1,3,5,8],构建霍夫曼树的流程如图：
![霍夫曼树](https://xymbucket.oss-cn-beijing.aliyuncs.com/blogs/Images/20211223161131.png)

- **红黑树**：红黑树是一种含有红黑结点并能*自平衡*的二叉查找树

性质：
①每个节点要么红色要么黑色
②根节点和所有叶子节点都是黑色的
③每个红色节点的两个子节点都是黑色的
④**任意一结点到每个叶子结点的路径都包含数量相同的黑节点**


>红黑树的插入：插入节点应为**红色**，保证红黑树的黑色平衡，若插入节点为黑色，则每次插入操作需要进行自平衡
插入流程：
1.确认插入位置，因为红黑树也是一颗检索二叉树，符合 左节点<父节点<右节点
2.不同插入场景下保证自平衡（符合红黑树性质）
![节点叫法约定](https://xymbucket.oss-cn-beijing.aliyuncs.com/blogs/Images/20211227105611.png)
场景1：空树插入，插入节点作为根节点，颜色设置为黑色
场景2：插入节点key存在，当前节点颜色不变，并更新插入值
场景3：插入节点父节点为黑色，直接插入，节点颜色为红色
场景4：插入节点父节点为红色，因为红色节点不能作为根节点，所以插入节点必存在祖父节点，当叔叔节点为黑色节点时，不符合性质④；当叔叔节点存在为红色时，插入节点和父节点均为红色，不符合性质③，需要进行自平衡调整如图：
![插入节点转换图](https://xymbucket.oss-cn-beijing.aliyuncs.com/blogs/Images/20211227215749.png)

>红黑树删除：
情景1：若删除结点无子结点，直接删除
情景2：若删除结点只有一个子结点，用子结点替换删除结点
情景3：若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点 --...对应多种具体情况
![红黑树节点删除思路](https://xymbucket.oss-cn-beijing.aliyuncs.com/blogs/Images/20211227221724.png)

        为什么红黑树使用红黑节点并且要求黑色完美平衡？
首先该该结构是为了保证搜索性能，红色节点的子节点只能为红节点，所以在红黑树当中红色节点的层数<=黑色节点层数，以此保证了最长路径（红黑相间）是最短路径（全黑节点）的两倍，其次在保证了搜索效率的同时红黑节点的转换又提高了树结构中插入和删除操作的效率，不需要频繁的进行旋转操作

- **B树**：B树(又称B-树)是一种自平衡的多叉搜索树
![B树](https://xymbucket.oss-cn-beijing.aliyuncs.com/blogs/Images/20211229233736.png)


>阶数：一个节点最多有多少个孩子节点。(一般用字母m表示)
关键字：节点上的数值就是关键字
性质：
1.根节点的儿子数量范围[2,M]
2.每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为 [ceil(M/2), M]。
3.叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M/2), M]。
4.假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]<Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。
5.所有叶子节点位于同一层。

- **B+树**：
![B+树](https://xymbucket.oss-cn-beijing.aliyuncs.com/blogs/Images/20211231105043.png)
性质：
1.孩子节点数量 = 关键字数量，非根节点关键字范围 **([m+1/2]-1 <= k <= m-1)**
2.非叶子节点只保存索引不保存数据记录（区别B树非叶子节点同样保存数据记录）
3.所有关键字都存在于叶子节点，叶子节点构成有序链表

优点：
- 非叶子节点只存索引，包含数据量更多，降低树的深度，减少IO
- 叶子节点为有序链表，适合范围查询；同样链表结构也有利于提高增删效率

>B+树插入---在树的叶子节点进行插入，①当叶子节点的关键字数(k <= m)时，直接插入；②当插入节点之后发现关键字数超过m,则进行分裂，将第m+1/2个关键字添加到父节点； ***自低向上*** 进行①②调整
4阶B+树分裂示意图：
![分裂图](https://xymbucket.oss-cn-beijing.aliyuncs.com/blogs/Images/20211231120049.png)

> B+树查找:
①单值查询：类似二叉搜索树查找方式，根据关键字比对结果，索引得到对应孩子节点
②范围查询：先通过单值查询得到左区间其实关键字，然后通过叶子节点之间的链表进行范围查询

> B+树删除:
①关键字个数大于m+1/2,直接删除
②关键字个数大于m+1/2，被删除关键字是节点最大（小）值时，这时需要删除关键字并调整父节点
③关键字个数小于m+1/2时，如果兄弟节点有多余关键字则借兄弟节点关键字，如果没有则与兄弟节点合并

- **B*树**：

B*树是B+树的变体，在树的非根节点和非叶子节点上增加指向兄弟节点的指针，指定非叶子节点的关键字个数至少为（2/3）*m，B*树比B+树效率要低，但是空间利用率要高

>B*树的分裂，当一个节点满时，如果它的兄弟节点未满，将会移动一部分关键字到兄弟节点再插入关键字，同时更新父节点；如果兄弟节点也满了，则当前节点和兄弟节点复制1/3的数据插入到新节点并更新父节点关键字指针

---

## 二、相关算法 

### 2.1 二叉树遍历
二叉树如图
![示例二叉树](https://xymbucket.oss-cn-beijing.aliyuncs.com/blogs/Images/20220104225514.png)
**前序遍历** --- 先访问根节点，再访问左子节点，最后访问右子节点{10,7,3,8,15,12,16}
```
// 前序遍历
public void preOrdeSearch(Node parent) {
    if (parent == null) {
        return;
    }
    // ①输出根节点
    System.out.print(parent.data + " -> ");
    // ②访问左子节点
    preOrdeSearch(parent.left);
    // ③访问右子节点
    preOrdeSearch(parent.right);
}
```

**中序遍历** --- 先访问左子节点，再访问根节点，最后访问右子节点{3,7,8,10,12,15,16}
**后序遍历** --- 先访问左子节点，再访问右子节点，最后访问根节点{3,8,7,10,12,16,15,10}


### 2.2 深度优先搜索（depth-first search - DFS）
**使用栈实现，从顶点开始压栈**
搜索算法规则：
规则1：如果可能，访问一个邻接的未访问顶点，标记它，并将它放入栈中。
规则2：当不能执行规则 1 时，如果栈不为空，就从栈中弹出一个顶点。
规则3：如果不能执行规则 1 和规则 2 时，就完成了整个搜索过程。
如图所示遍历顺序为 
**[A -> B -> F -> I -> J -> C-> D -> E -> H -> K-> L]**
![DFS](https://xymbucket.oss-cn-beijing.aliyuncs.com/blogs/Images/20220104220342.png)


### 2.3 广度优先搜索（breadth-first search - BFS）
**使用队列实现，先进先出，先访问邻接点**

搜索算法规则：
规则1：访问下一个未访问的邻接点（如果存在），这个顶点必须是当前顶点的邻接点，标记它，并把它插入到队列中
规则2：如果已经没有未访问的邻接点而不能执行规则 1 时，那么从队列列头取出一个顶点（如果存在），并使其成为当前顶点
规则3：如果因为队列为空而不能执行规则 2，则搜索结束

具体示例：**[A -> B -> C -> D -> E -> F -> H-> I -> J-> K]**
![BFS](https://xymbucket.oss-cn-beijing.aliyuncs.com/blogs/Images/20220104223556.png)

## 三、应用层面

应用到树相关数据结构的场景有很多：xml.html标签解析器、文件系统目录结构、电讯通信、**数据库索引和linux进程调度**

### 3.1 MySQL数据库索引

#### 3.1.1 聚簇索引和非聚簇索引

- 聚簇索引（聚集索引）：InnoDB作为存储引擎时，表中数据会有一个主键（未指定主键时则系统创建一个默认的隐式主键），InnoDB把数据存在B+树中，B+树的键值就是主键，该B+树存储了表中所有数据，**以主键作为B+树键值**的索引称为聚簇索引

- 非聚簇索引（非聚集索引）：以主键外的其他列作为键值构建的B+树索引称为非聚簇索引

#### 3.1.2 数据查找过程
非聚簇索引查找：
① 得到查询数据键值
② 根据键值在非聚簇索引B+树做搜索操作（B+树的查找），得到主键值
④ 用主键值在聚簇索引B+树中做搜索操作得到数据




## 四、面试题 

### 4.1 B+树常见面试题

        1.InnoDB一颗B+树能存放多少数据？
> 计算中存储数据的最小单位是比特(bit:位)，存储容量的最小单位是字节（Byte）,换算关系 ---- [1 Byte = 8 Bit]
在计算机中，磁盘存储数据最小单元是扇区，一个扇区的大小是512字节
文件系统中，最小单位是块，一个块大小就是4k
InnoDB存储引擎最小储存单元是页，**一页大小就是16k**

在B+树中，InnoDB的每页即作为树的一个节点
叶子节点存放数据记录，假设每行记录大小为1k,单个叶子节点存放的数据量为16k/k = 16;
非叶子节点存放索引,主键ID假设bigint类型8字节，指针在InnoDB中占用6字节，16k / 14B = 1170;
3层高的满B+树存放的数据量为 1170 * 1170 * 16 ~ 2200万行数据


        2.为什么索引结构默认使用B+树，而不使用B-Tree、Hash、二叉树和红黑树这些？
一个很直白的原因：数据库构建索引的目的是为了提升查询效率，相应的B+树结构在查询过程中拥有更少的磁盘IO,更快的查询速度
- Hash哈希适合等值查询，不适合范围查询 - 否
- 二叉树，因为单个节点最多只有两个子节点,这会导致树的深度很大，也有可能形成链表，相当于全表扫描，查询效率低 - 否
- 红黑树是特化平衡**二叉树**，当数据库数据量较大时，树的层次仍然会较高，磁盘次数过多
- B-Tree叶子节点和非叶子节点都用来存储数据，B+树更矮壮，磁盘IO会更少，查询速度更快



